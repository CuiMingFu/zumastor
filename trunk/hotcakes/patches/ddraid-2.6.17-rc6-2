diff -urp 2.6.17-rc6.clean/drivers/md/dm-ddsnap.c 2.6.17-rc6-dd/drivers/md/dm-ddsnap.c
--- 2.6.17-rc6.clean/drivers/md/dm-ddsnap.c	2006-08-07 23:25:31.000000000 +0000
+++ 2.6.17-rc6-dd/drivers/md/dm-ddsnap.c	2006-08-02 20:01:06.000000000 +0000
@@ -143,7 +143,6 @@ typedef u64 chunk_t;
 #define FINISH_FLAG (1 << 3)
 #define NUM_BUCKETS 64
 #define MASK_BUCKETS (NUM_BUCKETS - 1)
-#define ID_BITS 16
 
 struct devinfo {
 	u64 id;
@@ -329,9 +328,11 @@ int replied_rw(struct dm_target *target,
 	int i, j, submitted = 0;
 
 	trace(show_pending(info);)
-	trace(warn("id = %u, %u ranges, %s %s", body->id, body->count,
-		rw == READ? "read from": "write to", snap? "snapshot": "origin");)
-
+	if(snap) {
+		trace(warn("id = %u, %u ranges, %s %s", body->id, body->count,
+			rw == READ? "read from": "write to", snap? "snapshot": "origin");)
+	}
+			
 	for (i = 0; i < body->count; i++) { // !!! check for length overrun
 		unsigned chunks = p->chunks, id = body->id;
 		struct list_head *list, *bucket = info->pending + hash_pending(id);
@@ -504,7 +505,7 @@ connect:
 
 		case REPLY_SNAPSHOT_READ:
 			rw = READ;
-			to_snap = 1;
+			to_snap = 1; 
 			break;
 
 		case REPLY_IDENTIFY:
@@ -624,7 +625,7 @@ static void requeue_queries(struct devin
 		while (!list_empty(bucket)) {
 			struct list_head *entry = bucket->next;
 			struct pending *pending = list_entry(entry, struct pending, list);
-			trace_on(warn("requeue %u:%Lx", pending->id, pending->chunk);)
+			trace(warn("requeue %u:%Lx", pending->id, pending->chunk);)
 
 			list_move(entry, &info->queries);
 			up(&info->more_work_sem);
@@ -834,6 +835,10 @@ static int ddsnap_map(struct dm_target *
 	unsigned id;
 
 	bio->bi_bdev = info->orgdev->bdev;
+
+	/* linear mapping */
+	/* return 1; */
+	
 	if (bio_data_dir(bio) == READ && !is_snapshot(info))
 		return 1;
 
@@ -861,6 +866,8 @@ static int ddsnap_map(struct dm_target *
 			return 1;
 	}
 #endif
+
+	/* rob: check to see if the socket is connected, otherwise failed and don't place request on the queue */
 	id = info->nextid;
 	info->nextid = (id + 1) & ~(-1 << ID_BITS);
 	pending = kmem_cache_alloc(pending_cache, GFP_NOIO|__GFP_NOFAIL);
@@ -982,7 +989,6 @@ static int ddsnap_create(struct dm_targe
 #ifdef CACHE
 	unsigned bm_size;
 #endif
-
 	error = "ddsnap usage: orgdev snapdev sockname snapnum";
 	err = -EINVAL;
 	if (argc != 4)
@@ -1018,10 +1024,12 @@ static int ddsnap_create(struct dm_targe
 		INIT_LIST_HEAD(&info->pending[i]);
 
 	error = "Can't get snapshot device";
-	if ((err = dm_get_device(target, argv[0], 0, target->len, dm_table_get_mode(target->table), &info->snapdev)))
+	
+	if ((err = dm_get_device(target, argv[0], 0, 0, dm_table_get_mode(target->table), &info->snapdev)))
 		goto eek;
 	error = "Can't get origin device";
-	if ((err = dm_get_device(target, argv[1], 0, target->len, dm_table_get_mode(target->table), &info->orgdev)))
+	
+	if ((err = dm_get_device(target, argv[1], 0, 0, dm_table_get_mode(target->table), &info->orgdev)))
 		goto eek;
 	error = "Can't connect control socket";
 	if ((err = get_control_socket(argv[2])) < 0)
@@ -1046,7 +1054,7 @@ static int ddsnap_create(struct dm_targe
 		goto eek;
 	if ((err = kernel_thread((void *)control, target, CLONE_KERNEL)) < 0)
 		goto eek;
-	warn("Created snapshot device origin=%s snapstore=%s socket=%s snapshot=%i", argv[0], argv[1], argv[2], snap);
+	warn("Created snapshot device snapstore=%s origin=%s socket=%s snapshot=%i", argv[0], argv[1], argv[2], snap);
 	target->split_io = 1 << info->chunkshift; // !!! lose this as soon as possible
 	return 0;
 
@@ -1141,4 +1149,4 @@ void dm_ddsnap_exit(void)
 module_init(dm_ddsnap_init);
 module_exit(dm_ddsnap_exit);
 
-MODULE_LICENSE("GPL")
+MODULE_LICENSE("GPL");
diff -urp 2.6.17-rc6.clean/drivers/md/dm-ddsnap.h 2.6.17-rc6-dd/drivers/md/dm-ddsnap.h
--- 2.6.17-rc6.clean/drivers/md/dm-ddsnap.h	2006-08-07 23:25:31.000000000 +0000
+++ 2.6.17-rc6-dd/drivers/md/dm-ddsnap.h	2006-07-31 23:40:52.000000000 +0000
@@ -37,12 +37,19 @@ enum csnap_codes
 	REMOVE_CLIENT_IDS,
 	LIST_SNAPSHOTS,
 	SNAPSHOT_LIST,
+	GENERATE_CHANGE_LIST,
+	REPLY_GENERATE_CHANGE_LIST,
+	SET_PRIORITY,
+	REPLY_SET_PRIORITY,
 };
 
+#define ID_BITS 16
+
 struct match_id { uint64_t id; uint64_t mask; } PACKED;
 struct set_id { uint64_t id; } PACKED;
 struct identify { uint64_t id; int32_t snap; } PACKED;
 struct create_snapshot { uint32_t snap; } PACKED;
+struct generate_changelist { uint32_t snap1; uint32_t snap2; } PACKED;
 struct snapinfo { uint64_t snap; int8_t prio; char zero[3]; uint64_t ctime; } PACKED;
 struct snaplist { uint32_t count; struct snapinfo snapshots[]; } PACKED;
 
@@ -50,7 +57,7 @@ typedef uint16_t shortcount; /* !!! what
 
 struct rw_request
 {
-	uint16_t id;
+	uint32_t id;
 	shortcount count;
 	struct chunk_range
 	{
@@ -62,7 +69,7 @@ struct rw_request
 /* !!! can there be only one flavor of me please */
 struct rw_request1
 {
-	uint16_t id;
+	uint32_t id;
 	shortcount count;
 	struct chunk_range PACKED ranges[1];
 } PACKED;
diff -urp 2.6.17-rc6.clean/drivers/md/dm-table.c 2.6.17-rc6-dd/drivers/md/dm-table.c
--- 2.6.17-rc6.clean/drivers/md/dm-table.c	2006-06-15 00:56:05.000000000 +0000
+++ 2.6.17-rc6-dd/drivers/md/dm-table.c	2006-07-14 21:36:13.000000000 +0000
@@ -441,8 +441,10 @@ static int __table_get_device(struct dm_
 			return -EOVERFLOW;
 	} else {
 		/* convert the path to a device */
-		if ((r = lookup_device(path, &dev)))
+		if ((r = lookup_device(path, &dev))) {
+			printk("lookup_device\n");
 			return r;
+		}
 	}
 
 	dd = find_device(&t->devices, dev);
@@ -466,8 +468,10 @@ static int __table_get_device(struct dm_
 
 	} else if (dd->mode != (mode | dd->mode)) {
 		r = upgrade_mode(dd, mode, t->md);
-		if (r)
+		if (r) {
+			printk("upgrade_mode\n");
 			return r;
+		}
 	}
 	atomic_inc(&dd->count);
 
@@ -488,7 +492,11 @@ int dm_get_device(struct dm_target *ti, 
 {
 	int r = __table_get_device(ti->table, ti, path,
 				   start, len, mode, result);
+
+	/* printk("__table_get_device returned %d\n", r); */
+	
 	if (!r) {
+		/* printk("__table_get_device returns something good\n"); */
 		request_queue_t *q = bdev_get_queue((*result)->bdev);
 		struct io_restrictions *rs = &ti->limits;
