#!/bin/bash
# Zumastor Linux Storage Server
# Copyright (c) 2006 Google Inc.
# Author: Daniel Phillips <phillips@google.com>
# Licensed under the GNU GPL version 2

. /lib/zumastor/common || { echo "$0: unable to load common zumastor functions"; exit 1; }
. /lib/zumastor/ddfake

function new_snapshot {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r kind=$2
	local -r master=$VOLUMES/$vol/master
	local -r sock=${SERVERS}/$vol
	local -r maxfile=$master/schedule/$kind
	local -r listfile=$master/snapshots/$kind
	local -a snapshots
	local max
	local next
	local num
	local oldest

	echo "`date`: new '$kind' snapshot requested for volume '$vol'"

	[ -f $maxfile ] || { echo "$0: '$maxfile' is missing, doing nothing"; return 1; }
	read max <$maxfile
	[ $max ] || { echo "$0: '$maxfile' is empty, doing nothing"; return 1; }
	[ $max -gt 0 ] || { echo "$0: '$maxfile' contains zero, doing nothing"; return 1; }

	read next <$master/next
	echo $(( next+1 )) >$master/next
	echo "`date`: new snapshot will be '$next'"

	if [ -f $listfile ]; then
		read -a snapshots <$listfile
	else
		snapshots=()
	fi
	num=${#snapshots[@]}
	snapshots[$num]=$next

	ddsnap create $sock $next
	create_device $vol $next

	if [[ $num -ge $max ]]; then
		oldest=${snapshots[0]}
		remove_device $vol $oldest
		ddsnap delete $sock $oldest
		unset snapshots[0]
	fi
	echo ${snapshots[@]} >$listfile
	echo "`date`: '$kind' snapshot list is now: ${snapshots[@]}"
}

function replicate_snapshot {
	[ $# -eq 3 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r snap=$3

	echo "`date`: replication for snapshot '$snap' on volume '$vol' to '$host'"

	# !!! implement
}

function run_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r fifo=$VOLUMES/$vol/master/trigger
	local -r log=${LOGS}/${vol}-master.log
	local -r cron=${CRONS}/$vol
	local kind

	[ -r $fifo ] && [ -p $fifo ] || { echo "$0: master snapshot trigger '$fifo' is missing"; return 1; }
	touch ${CRONS}/$vol || return 1

	# daemonize (close stdin, stdout, stderr)
	exec 0</dev/null 1>/dev/null 2>/dev/null

	# we reopen the log for each write so rotation works
	echo "`date`: starting master snapshot daemon for volume '$vol': pid $$" >> $log
	while true; do
		read kind <$fifo || exit 1
		new_snapshot $vol $kind >> $log 2>&1
	done &
}

function run_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r fifo=$VOLUMES/$vol/targets/$host/trigger
	local -r log=${LOGS}/${vol}-target-${host}.log
	local snap

	[ -r $fifo ] && [ -p $fifo ] || { echo "$0: target replication trigger '$fifo' is missing"; return 1; }

	# daemonize (close stdin, stdout, stderr)
	exec 0</dev/null 1>/dev/null 2>/dev/null

	# we reopen the log for each write so rotation works
	echo "`date`: starting replication daemon of volume '$vol' to target '$host': pid $$" >> $log
	while true; do
		# !!! Implement skipping to most recent snapshot if there is a backlog
		read snap <$fifo || exit 1
		replicate_snapshot $vol $host $snap >> $log 2>&1
	done &
}

function stop_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r cron=${CRONS}/$vol

	rm -f $cron
	pkill -f "zumastor start master $vol" || return 1
}

function stop_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2

	pkill -f "zumastor start target $vol $host" || return 1
}

function define_volume {
	[ $# -eq 3 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r odev=$2
	local -r sdev=$3
	local -r path=$VOLUMES/$vol
	local -r sock=${SERVERS}/$vol

	mkdir $path || return 1
	mkdir $path/device || return 1
	ln -sf $odev $path/device/origin  || return 1
	ln -sf $sdev $path/device/snapstore || return 1
	mkdir $path/targets || return 1

	ddsnap create $sock -1 || return 1
	create_device $vol -1 || return 1
	# FIXME: check to see if there are any snapshots in the snapshot store and initialize here

	start_volume $vol || return 1
}

function forget_volume {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r path=$VOLUMES/$vol
	local -r sock=${SERVERS}/$vol
	local -r agentlog=${LOGS}/${vol}-agent.log
	local -r serverlog=${LOGS}/${vol}-server.log

	local id

	stop_volume $vol

	for host in $targets; do
		forget_target $vol $host
	done
	forget_master $vol

	# remove any snapshots devices first, then the origin
	for id in $(ddsnap status $sock --list); do
		remove_device $vol $id
	done
	remove_device $vol -1

	rmdir $path/targets
	rm -rf $path/device
	rm $agentlog $serverlog
	rmdir $path || return 1
}

function define_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol/targets/$host

	mkdir $path || return 1
	mkfifo $path/trigger || return 1
	zumastor start target $vol $host || return 1
}

function forget_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol/targets/$host

	zumastor stop target $vol $host
	rm -rf $path || return 1
}

function set_master {
	[ $# -eq 3 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r kind=$2
	local -r count=$3
	local -r path=$VOLUMES/$vol
	local new
	local conv

	if [ -d $path/source ]; then
		read -p "$vol is currently a downstream volume, convert to master? [n] " conv
		[ X$conv = Xy ] || [ X$conv = Xyes ] || return 1

		rm -rf $path/source
	fi

	[ -d $path/master ] || new=yes

	if [ $new ]; then
		mkdir $path/master || return 1
		mkdir $path/master/schedule || return 1
	fi

	if [ $count -gt 0 ]; then
		echo $count >$path/master/schedule/$kind || return 1
	else
		rm -f $path/master/schedule/$kind
	fi

	if [ $new ]; then
		echo 0 >$path/master/next || return 1
		mkdir $path/master/snapshots || return 1
		mkfifo $path/master/trigger || return 1
		zumastor start master $vol || return 1
	fi
}

function forget_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r path=$VOLUMES/$vol

	stop_master $vol
	[ -d $path/master ] && rm -rf $path/master
}

function set_source {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol
	local conv

	if [ -d $path/master ]; then
		read -p "$vol is currently a master, convert to a downstream volume? [n] " conv
		[ X$conv = Xy ] || [ X$conv = Xyes ] || return 1

		forget_master $vol
	fi

	mkdir $path/source || return 1
	mkdir $path/source/$host || return 1
}

function trigger_snapshot {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r kind=$2
	local -r fifo=$VOLUMES/$vol/master/trigger

	[ -r $fifo ] && [ -p $fifo ] || { echo "$0: volume '$vol' is not master"; return 1; }

	echo $kind >$fifo || return 1
}

function trigger_replication {
	[ $# -eq 2 ] || [ $# -eq 3 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local snap=$3
	local -r fifo=$VOLUMES/$vol/targets/$host/trigger

	# !!! update snap if empty

	[ -r $fifo ] && [ -p $fifo ] || { echo "$0: host '$host' is not a target for volume '$vol'"; return 1; }

	echo $snap >$fifo || return 1
}

function run_command {
	case $1 in
	define)
		case $2 in
		volume)
			[ $# -eq 5 ] || { echo "usage: $0 define volume <vol> <origin> <snapstore>"; exit 2; }
			local -r vol=$3
			local -r origin=$4
			local -r snapstore=$5

			verify_valid_volname $vol || { echo "$0: invalid volume name '$vol'"; exit 1; }
			verify_valid_device $origin || { echo "$0: invalid device '$origin'"; exit 1; }
			verify_valid_device $snapstore || { echo "$0: invalid device '$snapstore'"; exit 1; }

			define_volume $vol $origin $snapstore
			exit $? ;;
		target)
			[ $# -eq 4 ] || { echo "usage: $0 define target <vol> <host>"; exit 2; }
			local -r vol=$3
			local -r host=$4

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

			define_target $vol $host
			exit $? ;;
		master)
			[ $# -eq 5 ] || { echo "usage: $0 define master <vol> <kind> <count>"; exit 2; }
			local -r vol=$3
			local -r kind=$4
			local -r count=$5

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			find_in $kind ${KINDS[@]} || { echo "$0: unknown snapshot type '$kind'"; exit 1; }
			verify_valid_number $count || { echo "$0: bad snapshot count '$count'"; exit 1; }

			set_master $vol $kind $count
			exit $? ;;
		source)
			[ $# -eq 4 ] || { echo "usage: $0 define source <vol> <host>"; exit 2; }
			local -r vol=$3
			local -r host=$4

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

			set_source $vol $host
			exit $? ;;
		*)
			echo "usage: $0 define volume|target|master|source"
			exit 2 ;;
		esac
		;;
	forget)
		case $2 in
		volume)
			[ $# -eq 3 ] || { echo "usage: $0 forget volume <vol>"; exit 2; }
			local -r vol=$3

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

			forget_volume $vol
			exit $? ;;
		target)
			[ $# -eq 4 ] || { echo "usage: $0 forget target <vol> <host>"; exit 2; }
			local -r vol=$3
			local -r host=$4

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

			forget_target $vol $host
			exit $? ;;
		*)
			echo "usage: $0 forget volume|target"
			exit 2 ;;
		esac
		;;
	start)
		case $2 in
		master)
			[ $# -eq 3 ] || { echo "usage: $0 start master <vol>"; exit 2; }
			local -r vol=$3

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

			run_master $vol
			exit $? ;;
		target)
			[ $# -eq 4 ] || { echo "usage: $0 start target <vol> <host>"; exit 2; }
			local -r vol=$3
			local -r host=$4

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

			run_target $vol $host
			exit $? ;;
		*)
			echo "usage: $0 start master|target"
			exit 2 ;;
		esac
		;;
	stop)
		case $2 in
		master)
			[ $# -eq 3 ] || { echo "usage: $0 stop master <vol>"; exit 2; }
			local -r vol=$3

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

			stop_master $vol
			exit $? ;;
		target)
			[ $# -eq 4 ] || { echo "usage: $0 stop target <vol> <host>"; exit 2; }
			local -r vol=$3
			local -r host=$4

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

			stop_target $vol $host || exit 1
			exit $? ;;
		*)
			echo "usage: $0 stop master|target"
			exit 2 ;;
		esac
		;;
	snapshot)
		[ $# -eq 3 ] || { echo "usage: $0 snapshot <vol> <kind>"; exit 2; }
		local -r vol=$2
		local -r kind=$3

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		find_in $kind ${KINDS[@]} || { echo "$0: unknown snapshot type '$kind'"; exit 1; }

		trigger_snapshot $vol $kind
		exit $?
		;;
	replicate)
		[ $# -eq 4 ] || { echo "usage: $0 replicate <vol> <host> <snap>"; exit 2; }
		local -r vol=$2
		local -r host=$3
		local -r snap=$4

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		verify_existing_target $vol $host || { echo "$0: host '$host' is not a target for volume '$vol'"; exit 1; }
		[ -z $snap ] || verify_existing_snap $vol $snap || { echo "$0: invalid snapshot '$snap' for volume '$vol'"; exit 1; }

		trigger_replication $vol $host $snap
		exit $?
		;;
	status)
		[ $# -lt 4 ] || { echo "usage: $0 status [-f] [<vol> [<snap>]]"; exit 2; }

		# !!! zero or one arguments means to call tree for now
		if [ $# -lt 3 ]; then
			local -r opt=$2

			tree -Fx $opt $VOLUMES
			tree -Fx $opt $RUNPATH
			exit $?
		else
			local -r vol=$2
			local -r snap=$3
			local -r sock=${SERVERS}/$vol

			verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
			[ -z $snap ] || verify_existing_snap $vol $snap || { echo "$0: invalid snapshot '$snap' for volume '$vol'"; exit 1; }

			ddsnap status $sock $snap
			exit $?
		fi
		;;
	esac

	[ $# -gt 0 ] && echo "Error in command: $@"
	echo "Usage: $0 {define|forget|start|stop|snapshot|replicate|status} [<subarguments>...]"
	exit 2
}


[ -d $VOLUMES ] || { echo "$0: cannot find zumastor database in '$VOLUMES'"; exit 1; }
run_command "$@"

