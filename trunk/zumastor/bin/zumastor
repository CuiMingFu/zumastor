#!/bin/bash
# Zumastor Linux Storage Server
# Copyright (c) 2006 Google Inc.
# Author: Daniel Phillips <phillips@google.com>
# Licensed under the GNU GPL version 2

. /lib/zumastor/common || { echo "$0: unable to load common zumastor functions"; exit 1; }
. /lib/zumastor/ddfake

function read_and_inc {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r filename=$1
	local num

	# FIXME TODO add error 
	read num <$filename || num=0
	echo $(( num+1 )) > $filename || return 1

	echo $num

	return 0
}

function drop_snapshot {
	[[ $# -eq 2 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r snap=$2
	local -r server=$SERVERS/$vol
	local usecount

	log "dropping snapshot for $vol($snap)"
	usecount=$(ddsnap usecount $server $snap) || \
		{ log "couldn't get usecount for vol '$vol' snap '$snap'"; return 1; }
	[[ $usecount -eq 1 ]] || \
		{ log "trying to remove snapshot with usecount '$usecount'"; return 1; }

	remove_device $vol $snap || \
		{ log "remove device failed for $vol($snap) "; return 1; }

	# FIXME we wait for the usecount to hit zero
	while true; do
		usecount=$(ddsnap usecount $server $snap) || \
			{ log "couldn't get usecount for vol '$vol' snap '$snap'"; return 1; }
		verify_valid_number $usecount || \
			{ log "usecount didn't return valid number '$usecount'"; return 1; }
		[[ $usecount -eq 0 ]] && break
		sleep 1
	done
		
	ddsnap delete $server $snap || log "failed to delete snapshot '$vol($snap)'"
}

function umount_drop_snapshot {
	[[ $# -eq 2 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r snap=$2
	local -r server=$SERVERS/$vol

	umount_device $vol $snap || \
		{ log "error umounting $vol($snap)"; return 1; }

	drop_snapshot $vol $snap || return 1
}

# new_snapshot <volume name> <kind>
#  Create a new snapshot for <volume>'s interval <kind> and rotate out old
#  snapshots as necessary.  Called from the zumastor master when triggered with
#  an interval.
function new_snapshot {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r kind=$2
	local -r master=$VOLUMES/$vol/master
	local -r sock=${SERVERS}/$vol
	local -r maxfile=$master/schedule/$kind
	local -r listfile=$master/snapshots/$kind
	local -a snapshots
	local max
	local next
	local num
	local oldest

	log "new '$kind' snapshot requested for volume '$vol'"

	if [[ $kind != "manual" ]]; then
		[ -f $maxfile ] || { echo "$0: '$maxfile' is missing, doing nothing"; return 1; }
		read max <$maxfile
		[ $max ] || { echo "$0: '$maxfile' is empty, doing nothing"; return 1; }
		[ $max -gt 0 ] || { echo "$0: '$maxfile' contains zero, doing nothing"; return 1; }
	fi

	next=$(read_and_inc $master/next) || { log "snapshot number error: $master/next"; return 1; }
	log "new snapshot will be '$next'"

	if [ -f $listfile ]; then
		read -a snapshots <$listfile
	else
		snapshots=()
	fi
	num=${#snapshots[@]}
	snapshots[$num]=$next

	create_snapshot $vol $next
	create_device $vol $next

	[[ $kind == "manual" ]] && return 0
	mount_device $vol $next

	if [[ $num -ge $max ]]; then
		oldest=${snapshots[0]}

		# this will umount, remove device, and delete snapshot if it
		# is the only reference
		umount_drop_snapshot $vol $oldest
		#umount_device $vol $oldest
		#remove_device $vol $oldest
		#ddsnap delete $sock $oldest
		unset snapshots[0]
	fi
	echo ${snapshots[@]} >$listfile
	log "'$kind' snapshot list is now: ${snapshots[*]}"
}

function send_to_fifo {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r fifo=$1
	local -r data=$2

	[[ -e $fifo ]] || { echo "$fifo does not exist"; return 1; }
	[[ -p $fifo ]] || { echo "$fifo not a fifo"; return 1; }
	[[ -w $fifo ]] || { echo "$fifo not writable"; return 1; }

	echo $data > $fifo || { echo "error writing to $fifo"; return 1; }

	return 0
}

# new_target_snapshot <volume> <hostname>
#   Create a snapshot for <volume> for the replication to target <hostname> and
#   send the new snapshot number to the target's pipe.  Called by the zumastor
#   master daemon (run_master) when triggered with "target"
function new_target_snapshot {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r hostname=$2
	local -r target_fifo=$VOLUMES/$vol/targets/$hostname/trigger
	local -r sock=${SERVERS}/$vol
	local -r master=$VOLUMES/$vol/master
	local send_file send

	[ -e $target_fifo ] || { log "target trigger for $hostname does not exist"; return 1; }

	# create snapshot
	# write id down the trigger

	next=$(read_and_inc $master/next) || { log "ssn error: $master/next"; return 1; }

	log "new snapshot will be '$next'"

	# record the snapshot to be created first so that we remember to remove it properly during zumastor stop
	#send_file=$VOLUMES/$vol/targets/$hostname/send
	#if [[ -e $send_file ]]; then
	#	log "$send_file exists, cleaning up previous replication cycle"
	#	read -d' ' send <$send_file
	#	[[ -z $send ]] || drop_snapshot $vol $send
	#	rm $send_file
	#fi
	#echo $next > $send_file || { log "error writing snapshot id '$next' to '$send_file'"; \
	#	rm $send_file; drop_snapshot $vol $next; return 1; }

	# need to create the device in order for ddsnap transmit to work
	create_snapshot $vol $next
	create_device $vol $next
	# but we don't need to mount it

	send_to_fifo $target_fifo $next || return 1

}

function run_remote  {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r host=$1
	local -r command=$2

	# FIXME TODO input checking

	if [[ $host = "localhost" ]]; then
		echo $command | sh
	else
		# run "sh" to prevent "stdin: is not a tty" stderr output
		echo $command | $SSH_COMMAND $host sh
	fi
}

#function usecount_increment {
#	[[ $# -eq 2 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
#	local -r vol=$1
#	local -r snap=$2
#	local -r server=$SERVERS/$vol
#
#	# FIXME TODO input chekcing
#	ddsnap usecount $server $snap 1 || return 1
#}

# replicate_snapshot
# called from target zumastor daemon (run_target)
function replicate_snapshot {
	[ $# -eq 3 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r snap=$3
	local -r target_dir=$VOLUMES/$vol/targets/$host
	local -r send_file=$target_dir/send
	local -r hold_file=$target_dir/hold
	local -r server=$SERVERS/$vol
	local -r port_file=$target_dir/port
	local old_snap rem_snap port

	log "replication for snapshot '$snap' on volume '$vol' to '$host'"

	read old_snap <$hold_file || { echo "initial replication"; }

	rem_snap=$(run_remote $host "cat $VOLUMES/$vol/source/hostname") && [[ $rem_snap == $MYHOSTNAME ]] || \
		{ log "set '$MYHOSTNAME' as source for '$vol' on '$host' first!"; remove_device $vol $snap; return 1; }

	read port <$port_file || { log "error reading port from '$port_file'"; return 1; }

	rem_snap=$(run_remote $host "zumastor receive $vol $port start") || \
		{ log "starting remote snapshot receive failed"; return 1; }

	log "remote listen for volume '$vol' on '$host:$port' started"

	# in case of mismatch, do initial volume
	[[ $old_snap -ne $rem_snap ]] && old_snap=""

	# send the changes since the last snapshot via ddsnap transmit
	# cleanup in case of failure so that we roll back to full volume replication next time
	ddsnap transmit $server $host:$port -r -g 5 $old_snap $snap -p $send_file
	if [[ $? -ne 0 ]]; then
		log "transmit $server $host:$port $old_snap $snap failed"
		return 1
	fi

	run_remote $host "zumastor receive $vol $port done $snap"
	if [[ $? -ne 0 ]]; then
		log "zumastor receive $vol $port done $snap failed"
		return 1
	fi

	#[[ $snap -eq 5 ]] && restart_plug
	# !!! FIXME TODO this is racy, we should save state by journaling
	mv $send_file $hold_file
	echo $snap > $hold_file # to remove progress status

	[[ $old_snap ]] && drop_snapshot $vol $old_snap

	return 0
}

function restart_plug {
	echo "TESTING"
	/etc/init.d/zumastor restart
	exit
}

function run_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r fifo=$VOLUMES/$vol/master/trigger
	local -r log=${LOGS}/$vol/master.log
	local -r cron=${CRONS}/$vol
	local kind

	[ -r $fifo ] && [ -p $fifo ] || { echo "$0: master snapshot trigger '$fifo' is missing"; return 1; }
	touch ${CRONS}/$vol || return 1

	# daemonize (close stdin, stdout, stderr)
	#exec 0</dev/null 1>/dev/null 2>/dev/null

	mount_device $vol -1 rw

	# we reopen the log for each write so rotation works
	pid=""
	while true; do
		if [[ $pid == "" ]]; then
			pid=$!
			log "starting master snapshot daemon for volume '$vol'" $log
		fi
		# this is now overloaded to support two types of requests to create snapshots:
		# <kind> - which triggers a periodic snapshot (hourly, daily, etc)
		# target <hostname> - which triggers a snapshot for replication
		read kind hostname <$fifo || exit 1
		if [[ $kind = "target" ]]; then
			new_target_snapshot $vol $hostname >> $log 2>&1
		else
			find_in $kind ${KINDS[@]} || log "unknown snapshot type '$kind'" $log
			new_snapshot $vol $kind >> $log 2>&1
		fi
	done &
}

function run_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1 host=$2

	local -r fifo=$VOLUMES/$vol/targets/$host/trigger
	local -r period_file=$VOLUMES/$vol/targets/$host/period
	local -r log=${LOGS}/$vol/target-${host}.log
	local -r master_fifo=$VOLUMES/$vol/master/trigger
	local -r sleep_pid=$VOLUMES/$vol/targets/$host/.sleeppid
	local snap state period spid

	[ -r $fifo ] && [ -p $fifo ] || { log "target replication trigger '$fifo' is missing" $log; return 1; }

	[[ -e $period_file ]] && read period <$period_file || log "no period specified" $log

	if [[ ! -z $period ]]; then
		if verify_valid_number $period; then
			trigger_replication $vol $host $snap
		else
			log "invalid period '$period' specified" $log
			return 1
		fi
	fi

	# daemonize (close stdin, stdout, stderr)
	exec 0</dev/null 1>/dev/null 2>/dev/null

	pid=""
	while true; do
		if [[ $pid == "" ]]; then
			pid=$!
			log "start daemon volume '$vol', target '$host', period '$period'" $log
		fi
		# !!! FIXME TODO Implement skipping to most recent snapshot if there is a backlog

		log "waiting for new snapshot..." $log

		# wrap in a while loop because read will fail is ERESTARTSYS when the
		# sleeping child exits
		snap=""
		while [[ $snap == "" ]]; do
			[[ -r $fifo ]] || { log "$fifo not readable" $log; return 1; }
			read snap <$fifo
			sleep 1 # not necesary, just in case
		done

		replicate_snapshot $vol $host $snap >> $log 2>&1
		if [[ $? == 0 ]]; then #success 
			log "successfully replicated snapshot $snap" $log
			[[ -z $period ]] || (
				pid=$!
				log "sleeper starting" $log
				spid=""; read spid <$sleep_pid 2> /dev/null
				[[ $spid != "" ]] && { log "killing sleeper $spid" $log; kill $spid; }
				echo $pid > $sleep_pid
				log "sleeping ${period}s for replication cycle" $log
				sleep $period
				log "sleep completed, triggering replication" $log
				echo target $host > $VOLUMES/$vol/master/trigger
				rm $sleep_pid
				exit
			) &
		else
			log "replicate error on snapshot $snap: $?" $log
			drop_snapshot $vol $snap >> $log 2>&1
		fi
	done &
}

function stop_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r cron=${CRONS}/$vol
	local -r log=${LOGS}/$vol/master.log

	log "stop master called, umounting volume" $log
	umount_device $vol -1 2>/dev/null

	rm -f $cron
	log "killing master daemon" $log
	pkill -f "zumastor start master $vol$" || return 1
}

function stop_nag {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1

	pkill -f "ddsnap delta listen /dev/mapper/$vol 0.0.0.0"
	pkill -f "zumastor start source $vol$" || return 1
	pkill -f "ddsnap delta listen /dev/mapper/$vol 0.0.0.0" || return 1
	sync
}

function stop_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2

	pkill -f "zumastor start target $vol $host$" || return 1
	pkill -f "ddsnap transmit $SERVERS/$vol $host:" || return 1
	rm $VOLUMES/$vol/targets/$host/.sleeppid 2> /dev/null
}

function init_define_volume {
	[[ $# -eq 5 ]] || [[ $# -eq 6 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r odev=$2
	local -r sdev=$3
	local -r blocksize=$4
	local -r chunksize=$5
	local -r mdev=$6
	local -r path=$VOLUMES/$vol
	local -r sock=${SERVERS}/$vol
	local -r log=$LOGS/$vol/init.log

	mkdir $LOGS/$vol || return 1
	mkdir $path || return 1
	mkdir $path/device || return 1
	ln -sf $odev $path/device/origin  || return 1
	ln -sf $sdev $path/device/snapstore || return 1
	[ -z $mdev ] || ln -sf $mdev $path/device/meta || return 1
	mkdir $path/targets || return 1

	log "initializing volume '$vol', origindev '$odev', snapdev '$sdev'" $log
	# FIXME TODO -b $blocksize is not passed because it requires metadev
	ddsnap initialize -c $chunksize $sdev $odev $mdev 2>>$log || { echo init failed; return 1; }

	start_volume $vol || { echo start failed ;return 1; }

	create_device $vol -1 || { echo create failed;return 1; }
	# do not mount
}

function define_volume {
	[ $# -eq 3 ] || [ $# -eq 4 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r odev=$2
	local -r sdev=$3
	local -r mdev=$4
	local -r path=$VOLUMES/$vol
	local -r sock=${SERVERS}/$vol

	mkdir $LOGS/$vol || return 1
	mkdir $path || return 1
	mkdir $path/device || return 1
	ln -sf $odev $path/device/origin  || return 1
	ln -sf $sdev $path/device/snapstore || return 1
	[ -z $mdev ] || ln -sf $mdev $path/device/meta || return 1
	mkdir $path/targets || return 1

	start_volume $vol || { echo start failed ;return 1; }

	create_device $vol -1 || { echo create failed;return 1; }

	return 0
}

function forget_volume {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r path=$VOLUMES/$vol
	local -r sock=${SERVERS}/$vol
	local -r agentlog=${LOGS}/$vol/agent.log
	local -r serverlog=${LOGS}/$vol/server.log

	local id host targets

	pushd $VOLUMES/$vol/targets > /dev/null && \
	targets=`echo *` && \
	popd > /dev/null
	for host in $targets; do
		forget_target $vol $host
	done

	[ -d $VOLUMES/$vol/source ] && forget_source $vol

	forget_master $vol

	# remove any snapshots devices first, then the origin
	# FIXME racy because forget_target and forget_master just send a signal
	# to kill off the other processes taking shapshots
	for id in $(ddsnap status $sock --list); do
		umount_device $vol $id 2> /dev/null
		remove_device $vol $id
	done
	umount_device $vol -1 2> /dev/null
	remove_device $vol -1

	stop_volume $vol

	rmdir $path/targets
	rm -rf $path/device

	[[ -d $LOGS/.archived ]] || mkdir $LOGS/.archived
	mv $LOGS/$vol $LOGS/.archived/`date +%s`.$vol
	rmdir $path || return 1
}

function define_target {
	[[ $# -eq 3 ]] || [[ $# -eq 4 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r port=$3
	local -r period=$4
	local -r path=$VOLUMES/$vol/targets/$host

	if [[ -e $path ]]; then
		echo "$0: '$host' already set as target, updating configuration"
	else
		mkdir $path || return 1
		mkfifo $path/trigger || return 1
	fi

	echo $port > $path/port || return 1
	if [[ -z $period ]]; then
		rm $path/period 2> /dev/null
	else
		echo $period > $path/period || return 1
	fi

	stop_target $vol $host 2>/dev/null
	zumastor start target $vol $host || return 1
}

function forget_target {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol/targets/$host
	local -r holdfile=$path/hold
	local -r sendfile=$path/send
	local snap

	zumastor stop target $vol $host

	# clean up the hold snapshot
	read snap <$holdfile 2>/dev/null
	[[ $snap != "" ]] && drop_snapshot $vol $snap

	# clean up the send snapshot
	read snap <$sendfile 2>/dev/null
	[[ $snap != "" ]] && drop_snapshot $vol $snap

	rm -rf $path || return 1
}

function forget_source {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local hold

	zumastor stop source $vol
	# !!! FIXME TODO clean up replication in progress
	read hold <$VOLUMES/$vol/source/hold 2>/dev/null
	[[ $hold != "" ]] && drop_snapshot $vol $hold

	rm -rf $VOLUMES/$vol/source || return 1
	return 0
}

function define_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r path=$VOLUMES/$vol
	local conv

	if [ -d $path/source ]; then
		read -p "$vol is currently a downstream volume, convert to master? [n] " conv
		[[ $conv == "y" ]] || [[ $conv == "yes" ]] || return 1

		rm -rf $path/source
	fi

	mkdir $path/master || return 1
	mkdir $path/master/schedule || return 1

	echo 1 >$path/master/next || return 1
	mkdir $path/master/snapshots || return 1
	mkfifo $path/master/trigger || return 1
	zumastor start master $vol || return 1
}

function set_master_schedule {
	[ $# -eq 3 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r kind=$2
	local -r count=$3
	local -r path=$VOLUMES/$vol

	if [ $count -gt 0 ]; then
		echo $count >$path/master/schedule/$kind || return 1
	else
		rm -f $path/master/schedule/$kind
	fi

}

function forget_master {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r path=$VOLUMES/$vol

	# FIXME TODO clean up cron-created snapshots
	stop_master $vol
	[ -d $path/master ] && rm -rf $path/master
}

function set_source {
	[[ $# -eq 2 ]] || [[ $# -eq 3 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local -r period=$3
	local -r path=$VOLUMES/$vol
	local -r mysize=$(ddsnap status $SERVERS/$vol --size) || return 1
	local -r oldhost=$(cat $path/source/hostname 2>/dev/null)
	local conv rempath new=yes

	if [ -d $path/master ]; then
		read -p "volume '$vol' is currently a master, convert to a downstream volume? [n] " conv
		[[ $conv == "y" ]] || [[ $conv == "yes" ]] || return 1

		forget_master $vol
	fi

	rempath=$VOLUMES/$vol/targets/$MYHOSTNAME/trigger
	#conv=$(run_remote $host "ls $rempath 2>/dev/null") && [[ $conv = $rempath ]] || \
	#	{ echo "setup '$MYHOSTNAME' as target for volume '$vol' on '$host' first!"; return 1; }

	conv=$(run_remote $host "ddsnap status $SERVERS/$vol --size")
	[[ $conv -gt $mysize ]] && { echo "upstream volume ($conv) is larger than local ($mysize), cannot set source" ; return 1; }

	if [[ -e $path/source ]]; then
		new=no
		if [[ $oldhost != $MYHOSTNAME ]]; then
			read -p "source already set to '$oldhost', change to '$host'? [n] " conv
			[[ $conv == "y" ]] || [[ $conv == "yes" ]] || return 1
		fi
	fi

	[[ $new == "yes" ]] && { mkdir -p $path/source || return 1; }
	echo $host > $path/source/hostname || return 1

	if [[ -z $period ]]; then
		rm $path/source/period 2>/dev/null
	else
		echo $period > $path/source/period || return 1
	fi
}

function trigger_snapshot {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r kind=$2
	local -r fifo=$VOLUMES/$vol/master/trigger

	send_to_fifo $fifo $kind || return 1
}

function trigger_replication {
	[[ $# -eq 2 ]] || [[ $# -eq 3 ]] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r host=$2
	local snap=$3
	local -r target_fifo=$VOLUMES/$vol/targets/$host/trigger
	local -r master_fifo=$VOLUMES/$vol/master/trigger


	if [[ -z $snap ]]; then
		# no snapshot specified, asking the master for a new one
		send_to_fifo $master_fifo "target $host" || return 1
	else
		# increase reference count to pin snapshot
		#usecount_increment $vol $snap
		# send specified snapshot
		send_to_fifo $fifo $snap || { drop_snapshot $vol $snap; return 1; }
	fi
}

# replication_cycle -
# called on a downstream host after each ddsnap listen cycle
function replication_cycle {
	[ $# -eq 2 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r next=$2
	local -r sock=${SERVERS}/$vol
	local -r path=${VOLUMES}/$vol
	local -r holdfile=$path/source/hold
	local -r log=${LOGS}/$vol/source.log
	local next hold junk

	read hold <$holdfile

	if [[ -z $hold ]]; then
		hold=initial
	fi

	log "replication cycle beginning - snapshot ($hold, $next)..." $log

	log "creating snapshot..." $log
	create_snapshot $vol $next >> $log 2>&1

	log "creating device..." $log
	create_device $vol $next >> $log 2>&1

	log "setting snapshot unquashable..." $log
	set_priority $vol $next 127 >> $log 2>&1

	log "setting holdfile to $next" $log
	echo $next > $holdfile

	# FIXME TODO - we have to umount -l first, because umount always removes the topmost
	# filesystem :(, so we need to freeze access here
	if [[ $hold != "initial" ]]; then
		# NFS suspend
		echo "foo" > /proc/fs/nfsd/suspend 2>/dev/null
		log "umounting snapshot $hold " $log
		umount_device $vol $hold -l >> $log 2>&1
	fi

	log "mounting $vol($next)" $log
	mount_device $vol $next unqualified >> $log 2>&1

	if [[ $hold != "initial" ]]; then
		# NFS resume 
		cat /proc/fs/nfsd/suspend > /dev/null 2>&1
		drop_snapshot $vol $hold >> $log 2>&1
	fi

	log "cycle complete" $log
}

# nag_daemon
# daemon that runs in an endless loop, "nagging" upstream for replication
# data by writing "wakeup" to the target trigger to implement data "pull"
function nag_daemon {
	[ $# -eq 1 ] || { echo "$0: wrong argument count ($#: $@) in call: ${FUNCNAME[@]}"; exit 1; }
	local -r vol=$1
	local -r path=$VOLUMES/$vol
	local -r log=${LOGS}/$vol/nag.log
	local -r cron=${CRONS}/$vol
	local period
	local kind
	local host

	read host <$path/source/hostname
	read period <$path/source/period 2>/dev/null

	[[ $period -gt 0 ]] || { log "no polling period specified for $vol, nothing to do" $log; return 0; }

	# daemonize (close stdin, stdout, stderr)
	exec 0</dev/null 1>/dev/null 2>/dev/null

	pid=""
	while true; do
		if [[ $pid == "" ]]; then
			pid=$!
			log "nag daemon starting for volume '$vol'" $log
		fi

		log "sending wakeup to $host:" $log
		run_remote $host "echo target $MYHOSTNAME > $VOLUMES/$vol/master/trigger" >> $log 2>&1
		sleep $period
	done &
}

[[ -d $VOLUMES ]] || { echo "$0: cannot find zumastor database in '$VOLUMES'"; exit 1; }
[[ $1 == "stop" ]] || [[ $1 == "status" ]] || [[ -e $RUNFILE ]] || { echo "$0: zumastor not running, start with '/etc/init.d/zumastor start' first"; exit 1; }

case $1 in
define)
	case $2 in
	volume)
		declare args
		declare metadev=""
		declare noinit="noinit"
		declare name="$0 $1 $2"

		# these are the defaults
		declare blocksize=4k
		declare chunksize=16k

		shift 2
		args=`getopt -ob:c:m:hi -l blocksize:,chunksize:,help,metadev:,initialize -n"$name" -- "$@"` || \
			{ echo "usage: $name <vol> <origin> <snapstore> [Options]"; exit 2; }

		eval set -- "$args" # remove getopt quotes and set new arguments

		until [[ $1 = -- ]] ; do
			case "$1" in
			-h|--help)
				echo "usage: $name <vol> <origin> <snapstore> [Options]"
				echo "Options"
				echo "  -h, --help              show this help"
				echo "  -i, --initialize        initialize the volume with zeros (will destroy data)"
				echo "  -m, --metadev <device>  sets the metadata device (default is snapstore)"
				echo "  -b, --blocksize <size>  user-specified block size (default is $blocksize)"
				echo "  -c, --chunksize <size>  user-specified chunk size (default is $chunksize)"
				exit;;
			-i|--initialize) noinit="";;
			-m|--metadev) metadev=$2; shift 1;;
			-b|--blocksize) blocksize=$2; shift 1;;
			-c|--chunksize) chunksize=$2; shift 1;;
			*) echo whoops; exit 9;;
			esac
			shift 1
		done

		shift # remove --
		[[ $# = 3 ]] || { echo "usage: $name <vol> <origin> <snapstore> [Options]"; exit 2; }

		declare vol=$1
		declare origin=$2
		declare snapstore=$3
		
		verify_valid_volname $vol || { echo "$0: invalid volume name '$vol'"; exit 1; }
		verify_valid_device $origin || { echo "$0: invalid device '$origin'"; exit 1; }
		verify_valid_device $snapstore || { echo "$0: invalid device '$snapstore'"; exit 1; }
		[ -z $meta ] || verify_valid_device $metadev || { echo "$0: invalid device '$meta'"; exit 1; }

		if [[ $noinit = "noinit" ]]; then
			define_volume $vol $origin $snapstore $metadev || { echo "$0: define volume '$vol' failed"; exit 1; }
		else
			init_define_volume $vol $origin $snapstore $blocksize $chunksize $metadev \
				|| { echo "$0: init volume '$vol' failed"; exit 1; }

			echo "Successfully created and initialized volume '$vol'."
			echo "You can now create a filesystem on /dev/mapper/$vol"
		fi

		exit $? ;;
	target)
		[[ $# -eq 4 ]] || [[ $# -eq 5 ]] || { echo "usage: $0 define target <vol> <host>[:port] [period]"; exit 2; }
		declare vol=$3
		declare host=$4
		declare period=$5
		declare port=${host/*:/}

		# check to see if port was specified, if so, strip it off the host
		if [[ $host != $port ]]; then
			host=${host/:*/}
		else
			# otherwise use the default port
			port=$DEFAULT_PORT
		fi

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

		define_target $vol $host $port $period
		exit $? ;;
	master)
		declare args arg kind i
		declare -a token value

		declare name="$0 $1 $2"
		shift 2
		args=`getopt -oh:d:w:m: -l help,hourly:,daily:,weekly:,monthly: -n"$name" -- "$@"` || \
			{ echo "usage: $name <vol> [Options]"; exit 2; }

		eval set -- "$args" # remove getopt quotes and set new arguments

		until [[ $1 = -- ]] ; do
			case "$1" in
			--help)
				echo "usage: $name <vol> [Options]"
				echo "Options"
				echo "  -h, --hourly=N    set hourly snapshot limit"
				echo "  -d, --daily=N     set daily snapshot limit"
				echo "  -w, --weekly=N    set weekly snapshot limit"
				echo "  -m, --monthly=N   set monthly snapshot limit"
				exit;;
			-h|--hourly) kind=hourly;;
			-d|--daily) kind=daily;;
			-w|--weekly) kind=weekly;;
			-m|--monthly) kind=monthly;;
			*) echo whoops; exit 9;;
			esac
			verify_valid_number $2 || { echo $2 is not a valid $kind limit; exit 1; }
			token+=($kind)
			value+=($2)
			shift 2
		done

		shift # remove --
		[[ $# = 1 ]] || { echo "usage: $name <vol> [Options]"; exit 2; }

		declare vol=$1

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		if [ ! -e $VOLUMES/$vol/master ]; then
			define_master $vol || exit $?
		fi

		for (( i=0; i < ${#token[@]}; i++)) do
			set_master_schedule $vol ${token[i]} ${value[i]} || exit $?
		done

		exit 0 ;;
	source)
		[[ $# -eq 4 ]] || [[ $# -eq 5 ]] || { echo "usage: $0 define source <vol> <host> [period]"; exit 2; }
		declare vol=$3
		declare host=$4
		declare period=$5

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

		set_source $vol $host $period
		exit $? ;;
	*)
		echo "usage: $0 define volume|target|master|source"
		exit 2 ;;
	esac
	;;
forget)
	case $2 in
	volume)
		[ $# -eq 3 ] || { echo "usage: $0 forget volume <vol>"; exit 2; }
		declare vol=$3

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		forget_volume $vol
		exit $? ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 forget target <vol> <host>"; exit 2; }
		declare vol=$3
		declare host=$4

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

		forget_target $vol $host
		exit $? ;;
	source)
		[ $# -eq 3 ] || { echo "usage: $0 forget source <vol>"; exit 2; }
		declare vol=$3

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		forget_source $vol
		exit $? ;;
	*)
		echo "usage: $0 forget volume|target|source"
		exit 2 ;;
	esac
	;;
start)
	case $2 in
	master)
		[ $# -eq 3 ] || { echo "usage: $0 start master <vol>"; exit 2; }
		declare vol=$3

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		run_master $vol
		exit $? ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 start target <vol> <host>"; exit 2; }
		declare vol=$3
		declare host=$4

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

		run_target $vol $host
		exit $? ;;
	source)
		[ $# -eq 3 ] || { echo "usage: $0 start source <vol>"; exit 2; }
		declare vol=$3
		declare holdfile=$VOLUMES/$vol/source/hold
		declare log=${LOGS}/$vol/source.log
		declare snap=$(cat $holdfile 2>/dev/null)

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		if [[ ! -z $snap ]]; then
			log "mounting $vol($snap) on source start" $log
			mount_device $vol $snap unqualified >> $log 2>&1
		fi

		nag_daemon $vol
		exit $? ;;
	*)
		echo "usage: $0 start master|target|source"
		exit 2 ;;
	esac
	;;
stop)
	case $2 in
	master)
		[ $# -eq 3 ] || { echo "usage: $0 stop master <vol>"; exit 2; }
		declare vol=$3

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		stop_master $vol
		exit $? ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 stop target <vol> <host>"; exit 2; }
		declare vol=$3
		declare host=$4

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		verify_valid_host $host || { echo "$0: invalid host '$host'"; exit 1; }

		stop_target $vol $host || exit 1
		exit $? ;;
	source)
		[ $# -eq 3 ] || { echo "usage: $0 stop source <vol>"; exit 2; }
		declare vol=$3
		declare holdfile=$VOLUMES/$vol/source/hold
		declare log=${LOGS}/$vol/source.log
		declare snap=$(cat $holdfile 2>/dev/null)

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

		stop_nag $vol

		if [[ ! -z $snap ]]; then
			log "umounting $vol($snap) on source stop" $log
			umount_device $vol $snap unqualified >> $log 2>&1
		fi

		exit $? ;;
	*)
		echo "usage: $0 stop master|target|source"
		exit 2 ;;
	esac
	;;
snapshot)
	[[ $# -eq 2 ]] || [[ $# -eq 3 ]] || { echo "usage: $0 snapshot <vol> [kind]"; exit 2; }
	declare vol=$2
	declare kind=$3

	verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
	if [[ $# -eq 3 ]]; then
		find_in $kind ${KINDS[@]} || { echo "$0: unknown snapshot type '$kind'"; exit 1; }
	else
		kind="manual"
	fi
	
	trigger_snapshot $vol $kind
	exit $?
	;;
replicate)
	[[ $# -eq 3 ]] || [[ $# -eq 4 ]] || { echo "usage: $0 replicate <vol> <host> [snap]"; exit 2; }
	declare vol=$2
	declare host=$3
	declare snap=$4

	verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
	verify_existing_target $vol $host || { echo "$0: host '$host' is not a target for volume '$vol'"; exit 1; }
	[ -z $snap ] || verify_existing_snap $vol $snap || { echo "$0: invalid snapshot '$snap' for volume '$vol'"; exit 1; }

	# <snap> is optional and a new snapshot is taken if omitted
	trigger_replication $vol $host $snap
	exit $?
	;;
status)
	[ $# -lt 4 ] || { echo "usage: $0 status [-f] [<vol> [<snap>]]"; exit 2; }

	# !!! zero or one arguments means to call tree for now
	if [ $# -lt 3 ]; then
		declare opt=$2
		declare vol

		# for debugging
		#tree -Fx --noreport $opt $VOLUMES
		pushd $VOLUMES >/dev/null
		[[ `ls | wc -l` -gt 0 ]] && for vol in *; do
			echo VOLUME $vol:
			if [ -e $SERVERS/$vol ]; then
				ddsnap status $SERVERS/$vol && echo Status: running || echo Status: failed
			else
				echo Status: not running
			fi
			echo "Configuration:"
			tree -Fx --noreport $opt $VOLUMES/$vol
			echo
		done 2> /dev/null
		popd >/dev/null
		echo RUN STATUS:
		tree -Fx --noreport $opt $RUNPATH
		exit $?
	else
		declare vol=$2
		declare snap=$3
		declare sock=${SERVERS}/$vol

		verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }
		[ -z $snap ] || verify_existing_snap $vol $snap || { echo "$0: invalid snapshot '$snap' for volume '$vol'"; exit 1; }

		ddsnap status $sock $snap
		exit $?
	fi
	;;
receive)
	# called via upstream host's ssh command to start/stop listen
	[ $# -ge 4 ] || { echo "usage: $0 receive <vol> <port> {start|done <snap>}"; exit 2; }
	declare vol=$2
	declare port=$3
	declare startstop=$4
	declare holdfile=$VOLUMES/$vol/source/hold
	declare log=${LOGS}/$vol/delta.log
	declare rpid
	declare snap

	verify_managed_vol $vol || { echo "$0: volume '$vol' is not a managed volume"; exit 1; }

	case $startstop in
	start)
		[ $# -eq 4 ] || { echo "usage: $0 receive <vol> <port> start"; exit 2; }
		# !!! FIXME TODO if the hold file doesn't exist
		# assume we are initializing replication at snapshot 0
		read snap <$holdfile 2>/dev/null

		# start the listen daemon
		# FIXME TODO - for now we listen on 0.0.0.0 and we don't check where
		# the request came from, in the future, to avoid doing something
		# wrong, such as replicatin from 2 hosts, check the $SSH_CLIENT
		# environment variable

		# kill listen first in case it is already listening (previous replication interrupted)
		pkill -f "ddsnap delta listen /dev/mapper/$vol 0.0.0.0"

		rpid=$(ddsnap delta listen /dev/mapper/$vol 0.0.0.0:$port -l $log)

		# if successful, ouput should be "pid = <pid>"
		rpid=${rpid/pid = /}

		# if successful, send the hold snapid back to the caller
		[[ $rpid -gt 1 ]] && echo $snap
		exit $? ;;
	done)
		[ $# -eq 5 ] || { echo "usage: $0 receive <vol> <port> done <snap>"; exit 2; }
		pkill -f "ddsnap delta listen /dev/mapper/$vol 0.0.0.0"
		snap=$5
		replication_cycle $vol $snap

		exit $? ;;
	esac
	;;
esac

[ $# -gt 0 ] && echo "Error in command: $@"
echo "Usage: $0 {define|forget|start|stop|snapshot|replicate|status} [<subarguments>...]"
exit 2
