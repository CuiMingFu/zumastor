#!/bin/bash
# Zumastor Linux Storage Server
# Copyright (c) 2006 Google Inc.
# Author: Daniel Phillips <phillips@google.com>
# Licensed under the GNU GPL version 2

. /lib/zumastor/common
. /lib/zumastor/ddfake

function new_snapshot {
	local -r vol=$1
	local -r kind=$2
	local -r master=$VOLUMES/$vol/master
	local -r sock=/etc/zumastor/servers/$vol
	local -r maxfile=$master/schedule/$kind
	local -r listfile=$master/snapshots/$kind
	local -a snapshots
	local max
	local next
	local num
	local oldest

#echo "new_snapshot:"
#echo "vol=$vol kind=$kind"
	[ -f $maxfile ] || { echo "$maxfile is missing, doing nothing"; return 1; }
	read max <$maxfile
	[ $max ] || { echo "$maxfile is empty, doing nothing"; return 1; }
	[ $max -gt 0 ] || { echo "$maxfile contains zero, doing nothing"; return 1; }

	read next <$master/next
	echo $(( next+1 )) >$master/next
#echo "next=$next"

	if [ -f $listfile ]; then
		read -a snapshots <$listfile
	else
		snapshots=()
	fi
	num=${#snapshots[@]}
	snapshots[$num]=$next

	ddsnap create $sock $next
	create_device $vol $next

	if [[ $num -ge $max ]]; then
		oldest=${snapshots[0]}
		remove_device $vol $oldest
		ddsnap delete $sock $oldest
		unset snapshots[0]
	fi
	echo ${snapshots[@]} >$listfile
#echo "snapshots=${snapshots[@]}"
}

function run_master {
	local -r vol=$1
	local -r fifo=$VOLUMES/$vol/master/trigger
	local kind

	[ -r $fifo ] && [ -p $fifo ] || { echo "missing $fifo"; return 1; }
	touch /var/run/zumastor/cron/$vol || return 1

	# FIXME: daemonize (close stdin, stdout, stderr)
	while true; do
		read kind <$fifo || exit 1
		new_snapshot $vol $kind
	done &
}

function run_target {
	local -r vol=$1
	local -r host=$2
	local -r fifo=$VOLUMES/$vol/targets/$host/trigger
	local id

	[ -r $fifo ] && [ -p $fifo ] || { echo "missing $fifo"; return 1; }

	# FIXME: daemonize (close stdin, stdout, stderr)
	while true; do
		read id <$fifo || exit 1
		echo replicate $vol $host $id # !!!
	done &
}

function stop_master {
	local -r vol=$1

	rm -f /var/run/zumastor/cron/$vol
	pkill -f "zumastor start master $vol"
}

function stop_target {
	local -r vol=$1
	local -r host=$2

	pkill -f "zumastor start target $vol $host"
}

function define_volume {
	local -r vol=$1
	local -r odev=$2
	local -r sdev=$3
	local -r path=$VOLUMES/$vol
	local -r sock=/etc/zumastor/servers/$vol

	mkdir $path || return 1
	mkdir $path/device || return 1
	ln -sf $odev $path/device/origin  || return 1
	ln -sf $sdev $path/device/snapstore || return 1
	mkdir $path/targets || return 1
	# FIXME: check to see if there are any snapshots in the snapshot store and initialize here
	start_volume $vol || return 1
	ddsnap create $sock -1 || return 1
	create_device $vol -1 || return 1
}

function forget_volume {
	local -r vol=$1
	local -r path=$VOLUMES/$vol
	local -r sock=/etc/zumastor/servers/$vol

	# FIXME: cleanup any target or master daemons here
	rmdir $path/targets
	rm -rf $path/device

	# get a list of snapshots and remove them first
	local id
	for id in $(ddsnap status $sock --list); do
		remove_device $vol $id
		ddsnap delete $sock $id
	done

	remove_device $vol -1
	ddsnap delete $sock -1
	forget_master $vol
	stop_volume $vol
	rmdir $path
}

function define_target {
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol/targets/$host

	mkdir $path || return 1
	mkfifo $path/trigger || return 1
	zumastor start target $vol $host || return 1
}

function forget_target {
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol/targets/$host

	rm -rf $path
}

function set_master {
	local -r vol=$1
	local -r kind=$2
	local -r count=$3
	local -r path=$VOLUMES/$vol
	local new

	rm -rf $path/source # need to prompt

	find_in $kind ${KINDS[@]} || { echo "$0: unknown snapshot type $kind"; return 1; }

	[ -d $path/master ] || new=yes

	if [ $new ]; then
		mkdir $path/master || return 1
		mkdir $path/master/schedule || return 1
	fi

	if [ $count -gt 0 ]; then
		echo $count >$path/master/schedule/$kind || return 1
	else
		rm -f $path/master/schedule/$kind
	fi

	if [ $new ]; then
		echo 0 >$path/master/next || return 1
		mkdir $path/master/snapshots || return 1
		mkfifo $path/master/trigger || return 1
		zumastor start master $vol
	fi
}

function forget_master {
	local -r vol=$1
	local -r path=$VOLUMES/$vol

	stop_master $vol
	[ -d $path/master ] && rm -rf $path/master
}

function set_source {
	local -r vol=$1
	local -r host=$2
	local -r path=$VOLUMES/$vol

	forget_master $vol
	mkdir $path/source || return 1
	mkdir $path/source/$host
}

declare -r VOLUMES=/var/lib/zumastor/volumes
declare -ar KINDS=(hourly daily weekly monthly)

test -x $VOLUMES || { echo Cannot find zumastor database; exit 1; }

case $1 in
define)
	case $2 in
	volume)
		[ $# -eq 5 ] || { echo "usage: $0 define volume <vol> <origin> <snapstore>"; exit 2; }
		verify_volname $3 || { echo "$0: invalid volume name $3"; exit 1; }
		define_volume $3 $4 $5
		exit ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 define target <vol> <host>"; exit 2; }
		define_target $3 $4
		exit ;;
	master)
		[ $# -eq 5 ] || { echo "usage: $0 define master <vol> <kind> <count>"; exit 2; }
		set_master $3 $4 $5
		exit ;;
	source)
		[ $# -eq 4 ] || { echo "usage: $0 define source <vol> <host>"; exit 2; }
		set_source $3 $4
		exit ;;
	*)
		echo "usage: $0 define volume|target|master|source"
		exit 2 ;;
	esac
	;;
forget)
	case $2 in
	volume)
		[ $# -eq 3 ] || { echo "usage: $0 forget volume <vol>"; exit 2; }
		forget_volume $3
		exit ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 forget target <vol> <host>"; exit 2; }
		forget_target $3 $4
		exit ;;
	*)
		echo "usage: $0 forget volume|target"
		exit 2 ;;
	esac
	;;
start)
	case $2 in
	master)
		[ $# -eq 3 ] || { echo "usage: $0 start master <vol>"; exit 2; }
		run_master $3
		exit ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 start target <vol> <host>"; exit 2; }
		run_target $3 $4
		exit ;;
	*)
		echo "usage: $0 start master|target"
		exit 2 ;;
	esac
	;;
stop)
	case $2 in
	master)
		[ $# -eq 3 ] || { echo "usage: $0 stop master <vol>"; exit 2; }
		stop_master $3
		exit ;;
	target)
		[ $# -eq 4 ] || { echo "usage: $0 stop target <vol> <host>"; exit 2; }
		stop_target $3 $4
		exit ;;
	*)
		echo "usage: $0 stop master|target"
		exit 2 ;;
	esac
	;;
snapshot)
	[ $# -eq 3 ] || { echo "usage: $0 snapshot <vol> <kind>"; exit 2; }
	declare -r vol=$2
	declare -r kind=$3

	find_in $kind ${KINDS[@]} || { echo "$0: unknown snapshot type $kind"; exit 1; }

	[ -e $VOLUMES/$vol/master/trigger ] || { echo $0: volume \'$vol\' not master; exit 1; }

	echo $kind >$VOLUMES/$vol/master/trigger
	exit
	;;
replicate)
	[ $# -eq 4 ] || { echo "usage: $0 replicate <vol> <host> <snap>"; exit 2; }
	declare -r vol=$2
	declare -r host=$3
	declare -r snap=$4

	echo replicate $vol\($snap\) to $host #!!!
	echo $snap >$VOLUMES/$vol/targets/$host/trigger
	exit
	;;
status)
	[ $# -le 2 ] || { echo "usage: $0 status [-f]"; exit 2; }
	tree -Fx $2 $VOLUMES
	tree -Fx $2 /var/run/zumastor
	exit
	;;
esac

echo "Error: $@"
echo "Usage: $0 define|forget|start|stop|snapshot|replicate|status [<subcommand>] [<options>...]"
exit 2

