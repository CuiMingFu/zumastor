--- /dev/null	2006-05-22 07:25:23.000000000 -0700
+++ linux-2.6.21.1/Documentation/accounting/getrusage.txt	2007-08-24 13:04:35.000000000 -0700
@@ -0,0 +1,53 @@
+Notes on implementation of getrusage() in Linux 2.6.
+
+The getrusage() system call is used to retrieve two sets of process statistics
+associated with the running process and its children.  The first is indicated
+by RUSAGE_SELF as the first parameter to the function and gets the current
+statistics for the calling process itself.  The second is indicated by
+RUSAGE_CHILDREN and gets statistics for terminated, reaped (that is, wait()ed-
+for) child processes.
+
+For reference, the rusage structure is (from include/linux/resource.h):
+
+	struct rusage {
+	    struct timeval ru_utime;    // user time used		*
+	    struct timeval ru_stime;    // system time used		*
+	    long    ru_maxrss;          // maximum resident set size	*
+	    long    ru_ixrss;           // integral shared memory size
+	    long    ru_idrss;           // integral unshared data size
+	    long    ru_isrss;           // integral unshared stack size
+	    long    ru_minflt;          // page reclaims		*
+	    long    ru_majflt;          // page faults			*
+	    long    ru_nswap;           // swaps
+	    long    ru_inblock;         // block input operations	*
+	    long    ru_oublock;         // block output operations	*
+	    long    ru_msgsnd;          // messages sent
+	    long    ru_msgrcv;          // messages received
+	    long    ru_nsignals;        // signals received
+	    long    ru_nvcsw;           // voluntary context switches	*
+	    long    ru_nivcsw;          // involuntary "		*
+	};          
+                  
+Linux maintains and returns the fields marked with an asterisk ("*").  These
+statistics are kept in the process signal_struct and are updated in a handful
+of places in the kernel.  In the case of RUSAGE_SELF, the statistics are
+copied directly from the process signal structure.
+
+In the case of RUSAGE_CHILDREN, no child statistics are returned for children
+that have not both exited and been wait()ed for.  This means that no statistics
+will be returned for children for which SIGCHLD was ignored or SA_NOCLDWAIT
+was set.  When a process exits, if the kernel determines that no process will
+wait for it the task is released and any accumulated statistics are discarded.
+Otherwise it leaves a zombie which retains those statistics in the signal
+structure pointed to by the zombie task_struct.  When the parent calls wait(2),
+the kernel (in wait_task_zombie()) collects the child's statistics in the
+"children" statistics fields in the parent's signal structure.  The content of
+these fields are reported to the parent when it calls getrusage() with the
+RUSAGE_CHILDREN parameter.
+
+When the kernel "collects" child statistics, most of the statistics are simply
+added to the parent process "child" fields, which then cumulcontain the
+cumulative sum of those statistics for all of its terminated, wait()ed-for
+children.  The ru_maxrss field is slightly different in that it is only updated
+when the new value is larger than the older value; it tracks the largest RSS
+of all children.
--- Linux/linux-2.6.21.1/kernel/fork.c	2007-04-27 14:49:26.000000000 -0700
+++ linux-2.6.21.1/kernel/fork.c	2007-08-22 16:08:17.000000000 -0700
@@ -875,6 +875,7 @@ static inline int copy_signal(unsigned l
 	sig->nvcsw = sig->nivcsw = sig->cnvcsw = sig->cnivcsw = 0;
 	sig->min_flt = sig->maj_flt = sig->cmin_flt = sig->cmaj_flt = 0;
 	sig->sched_time = 0;
+	sig->cmaxrss = 0;
 	INIT_LIST_HEAD(&sig->cpu_timers[0]);
 	INIT_LIST_HEAD(&sig->cpu_timers[1]);
 	INIT_LIST_HEAD(&sig->cpu_timers[2]);
--- Linux/linux-2.6.21.1/kernel/exit.c	2007-07-30 18:03:18.000000000 -0700
+++ linux-2.6.21.1/kernel/exit.c	2007-08-22 16:09:02.000000000 -0700
@@ -116,6 +116,11 @@ static void __exit_signal(struct task_st
 		sig->nvcsw += tsk->nvcsw;
 		sig->nivcsw += tsk->nivcsw;
 		sig->sched_time += tsk->sched_time;
+		if (tsk->mm != NULL) {
+			update_hiwater_rss(tsk->mm);
+			if (tsk->mm->hiwater_rss > sig->cmaxrss)
+				sig->cmaxrss = tsk->mm->hiwater_rss;
+		}
 		sig = NULL; /* Marker for below. */
 	}
 
@@ -904,6 +909,8 @@ fastcall NORET_TYPE void do_exit(long co
 	if (tsk->mm) {
 		update_hiwater_rss(tsk->mm);
 		update_hiwater_vm(tsk->mm);
+		if (tsk->mm->hiwater_rss > tsk->signal->cmaxrss)
+			tsk->signal->cmaxrss = tsk->mm->hiwater_rss;
 	}
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
 	if (group_dead) {
@@ -1194,6 +1201,8 @@ static int wait_task_zombie(struct task_
 			p->nvcsw + sig->nvcsw + sig->cnvcsw;
 		psig->cnivcsw +=
 			p->nivcsw + sig->nivcsw + sig->cnivcsw;
+		if (sig->cmaxrss > psig->cmaxrss)
+			psig->cmaxrss = sig->cmaxrss;
 		spin_unlock_irq(&p->parent->sighand->siglock);
 	}
 
--- Linux/linux-2.6.21.1/kernel/sys.c	2007-08-16 09:50:30.000000000 -0700
+++ linux-2.6.21.1/kernel/sys.c	2007-08-22 16:07:48.000000000 -0700
@@ -2002,6 +2002,7 @@ static void k_getrusage(struct task_stru
 	struct task_struct *t;
 	unsigned long flags;
 	cputime_t utime, stime;
+	unsigned long hiwater_rss;
 
 	memset((char *) r, 0, sizeof *r);
 	utime = stime = cputime_zero;
@@ -2021,9 +2022,12 @@ static void k_getrusage(struct task_stru
 			r->ru_nivcsw = p->signal->cnivcsw;
 			r->ru_minflt = p->signal->cmin_flt;
 			r->ru_majflt = p->signal->cmaj_flt;
+			r->ru_maxrss = p->signal->cmaxrss;
 
-			if (who == RUSAGE_CHILDREN)
+			if (who == RUSAGE_CHILDREN) {
+				r->ru_maxrss <<= PAGE_SHIFT - 10;
 				break;
+			}
 
 		case RUSAGE_SELF:
 			utime = cputime_add(utime, p->signal->utime);
@@ -2042,6 +2046,13 @@ static void k_getrusage(struct task_stru
 				r->ru_majflt += t->maj_flt;
 				t = next_thread(t);
 			} while (t != p);
+			update_hiwater_rss(p->mm);
+			hiwater_rss = p->mm->hiwater_rss;
+			if (hiwater_rss < p->signal->cmaxrss)
+				hiwater_rss = p->signal->cmaxrss;
+			if (r->ru_maxrss < hiwater_rss)
+				r->ru_maxrss = hiwater_rss;
+			r->ru_maxrss <<= PAGE_SHIFT - 10;
 			break;
 
 		default:
--- Linux/linux-2.6.21.1/include/linux/sched.h	2007-07-30 18:03:17.000000000 -0700
+++ linux-2.6.21.1/include/linux/sched.h	2007-08-22 16:08:07.000000000 -0700
@@ -457,6 +457,7 @@ struct signal_struct {
 	cputime_t utime, stime, cutime, cstime;
 	unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
 	unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
+	unsigned long cmaxrss;
 
 	/*
 	 * Cumulative ns of scheduled CPU time for dead threads in the
