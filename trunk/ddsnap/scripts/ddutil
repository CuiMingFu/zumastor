#!/bin/sh

# ddutil - a wrapper for the ddsnap command
version="1.1"

# default location of configuration file
conf_file=/etc/ddutil.conf


# setup default configuration

# base block devices
dev_origin=/dev/origin
dev_snapstore=/dev/snapstore
dev_meta=

# device mapper devices
map_path=/dev/mapper
map_stem=snap

# Unix domain sockets
# FIXME: use a safer location
ddsnapd_sockpath=/tmp/server
agent_sockpath=/tmp/control

# log files
ddsnap_agent_log=/var/log/ddsnap_agent.log
ddsnap_server_log=/var/log/ddsnap_server.log
ddsnap_delta_log=/var/log/ddsnap_delta.log

# pid files
ddsnap_agent_pid=/var/run/ddsnap_agent.pid
ddsnap_server_pid=/var/run/ddsnap_server.pid
ddsnap_delta_pid=/var/run/ddsnap_delta.pid



usage_initialize()
{
    echo "$@initialize [<option>...]"
    echo "    -y, --yes                 Answer yes to all prompts"
    echo "    -j, --journal_size=JS     User specified journal size"
    echo "    -b, --block_size=BS       User specified block size"
}

usage_agent()
{
    echo "$@agent [<option>...]"
    echo "    -f, --foreground          Do not daemonize"
}

usage_server()
{
    echo "$@server [<option>...]"
    echo "    -f, --foreground          Do not daemonize"
}

usage_create()
{
    echo "$@create <snapshot>"
}

usage_delete()
{
    echo "$@delete <snapshot>"
}

usage_list()
{
    echo "$@list"
}

usage_priority()
{
    echo "$@priority <snap_tag> <new_priority_value>"
}

usage_usecount()
{
    echo "$@usecount <snap_tag> <inc|dec>"
}

usage_status()
{
    echo "$@status [<option>...] [<snapshot>]"
    echo "    -v, --verbose             Print all sharing statistics"
    echo "    --last                    Print the newest snapshot id"
    echo "    -l, --list                Print all active snapshot ids"
    echo "    -s, --size                Print the size of the origin device"
}

usage_delta_changelist()
{
    echo "$@delta changelist <changelist> <snapshot1> <snapshot2>"
}

usage_delta_create()
{
    echo "$@delta create [<option>...] <changelist> <deltafile> <snapshot1> <snapshot2>"
    echo "    -x, --xdelta              Delta file format: xdelta chunk"
    echo "    -r, --raw                 Delta file format: raw chunk from later"
    echo "                              snapshot"
    echo "    -t, --test                Delta file format: xdelta chunk, raw chunk"
    echo "                              from earlier snapshot and raw chunk from"
    echo "                              later snapshot"
    echo "    -g, --gzip=LEVEL          Compression via gzip"
    echo "    -o, --optcomp             Optimal compression (slowest)"
}

usage_delta_apply()
{
    echo "$@delta apply <deltafile>"
}

usage_delta_send()
{
    echo "$@delta send [<option>...] <snapshot1> <snapshot2> <remsnapshot> <host>[:<port>]"
    echo "    -x, --xdelta              Delta file format: xdelta chunk"
    echo "    -r, --raw                 Delta file format: raw chunk from later"
    echo "                              snapshot"
    echo "    -t, --test                Delta file format: xdelta chunk, raw chunk"
    echo "                              from earlier snapshot and raw chunk from"
    echo "                              later snapshot"
    echo "    -g, --gzip=LEVEL          Compression via gzip"
    echo "    -o, --optcomp             Optimal compression (slowest)"
}

usage_delta_listen()
{
    echo "$@delta listen [<host>[:<port>]]"
    echo "    -f, --foreground          Do not daemonize"
}

usage_subcommands_short()
{
    echo ""
    echo "subcommands:"

    echo "   initialize         Initialize the snashot store"
    echo "   agent              Start the snapshot agent"
    echo "   server             Start the snapshot server"
    echo "   create             Create a snapshot"
    echo "   delete             Delete a snapshot"
    echo "   list               Return the list of current snapshots"
    echo "   priority           Set the priority of a snapshot"
    echo "   usecount           Changes the use count of a snapshot"
    echo "   status             Report snapshot usage statistics"
    echo "   delta changelist   Create a changelist given 2 snapshots"
    echo "   delta create       Create a delta file given a changelist and 2 snapshots"
    echo "   delta apply        Apply a delta file to a device"
    echo "   delta send         Send a delta downstream"
    echo "   delta listen       Listen for deltas arriving from upstream"
}

usage_subcommands_long()
{
    echo ""
    echo "subcommands:"

    echo ""
    usage_initialize "  "
    echo ""
    usage_agent "  "
    echo ""
    usage_server "  "
    echo ""
    usage_create "  "
    echo ""
    usage_delete "  "
    echo ""
    usage_list "  "
    echo ""
    usage_priority "  "
    echo ""
    usage_usecount "  "
    echo ""
    usage_status "  "
    echo ""
    usage_delta_changelist "  "
    echo ""
    usage_delta_create "  "
    echo ""
    usage_delta_apply "  "
    echo ""
    usage_delta_send "  "
    echo ""
    usage_delta_listen "  "
}

usage()
{
    echo "usage: $0 [<option>...] <subcommand> [<suboption>...]"
    echo "    -c, --config=FILE      use FILE for configuration"
    echo "    -h, --help, --usage    print usage and exit"
    echo "    -V, --version          print version information and exit"
}


# parse command line

newargs=`getopt -o '+hc:V' -l 'help,usage,config:,version' -n "$0" -- "$@"`
if [ $? != 0 ]; then
    exit 1
fi
# ugly quoting hack with eval
eval set -- "${newargs}"

subcommand=""

while [ $# -ge 1 ]; do
    case "$1" in
        -h|--help|--usage)
            usage
            usage_subcommands_long
            exit 0
            ;;

        -c|--config)
            conf_file="$2"
            shift
            shift
            ;;

        -V|--version)
            echo "ddutil ${version}"
            ddsnap -V
            exit 0
            ;;

        --)
            shift
            # if there's no next arg that's ok, an empty command will print usage
            subcommand="$1"
            shift
            break
            ;;

        *)
            echo "$0: unexpected argument $1" >& 2
            usage
            exit 1
            ;;
    esac
done


if [ X"${subcommand}" = X"" ]; then
    usage
    usage_subcommands_short
    exit 0
fi

if [ X"${subcommand}" = X"delta" ]; then
    if [ $# -lt 1 ]; then
        echo "$0: incomplete ${subcommand} command" >&2
        usage >& 2
        usage_subcommands_short >& 2
        exit 0
    fi
    subcommand="${subcommand} $1"
    shift
fi


case "${subcommand}" in
    initialize)
        minargs='0'
        maxargs='0'
        shortopts='yj:b:'
        longopts='yes,journal_size:,block_size:'
        ;;

    agent|server)
        minargs='0'
        maxargs='0'
        shortopts='fl:p:'
        longopts='foreground,logfile:,pidfile:'
        ;;

    create|delete)
        minargs='1'
        maxargs='1'
        shortopts=''
        longopts=''
        ;;

    list)
        minargs='0'
        maxargs='0'
        shortopts=''
        longopts=''
        ;;

    status)
        minargs='0'
        maxargs='1'
        shortopts='vls'
        longopts='verbose,last,list,size'
        ;;

    priority|usecount|delta\ apply)
        minargs='1'
        maxargs='1'
        shortopts=''
        longopts=''
        ;;

    delta\ changelist)
        minargs='3'
        maxargs='3'
        shortopts=''
        longopts=''
        ;;

    delta\ create|delta\ send)
        minargs='4'
        maxargs='4'
        shortopts='xrtg:o'
        longopts='xdelta,raw,test,gzip:,optcomp'
        ;;

    delta\ listen)
        minargs='0'
        maxargs='1'
        shortopts='fl:p:'
        longopts='foreground,logfile:,pidfile:'
        ;;

    *)
        echo "$0: unknown subcommand \"${subcommand}\"" >&2
        exit 2
        ;;
esac


usage_func="usage_`echo \"${subcommand}\" | tr ' ' '_'`"


newargs=`getopt -o "+h${shortopts}" -l "help,usage,${longopts}" -n "$0 ${subcommand}" -- "$@"`
if [ $? != 0 ]; then
    exit 1
fi
# ugly quoting hack with eval
eval set -- "${newargs}"

suboptions=""
while [ $# -ge 1 ]; do
    case "$1" in
        -h|--help|--usage)
            "${usage_func}" "usage: $0 "
            exit 0
            ;;

        --)
            shift
            break
            ;;

        --*)
            # we will assume options won't contain whitespace, otherwise this would be a lot uglier
            if echo "${shortopts}" | egrep '^([^,]*,)*'"$1"':(,[^,]*)*$' > /dev/null; then
                suboptions="${suboptions} $1=$2"
                shift
            else
                suboptions="${suboptions} $1"
            fi
            shift
            ;;

        -)
            break
            ;;

        -*)
            # we will assume options won't contain whitespace, otherwise this would be a lot uglier
            if echo "${shortopts}" | egrep '^([^,]*,)*'"$1"':(,[^,]*)*$' > /dev/null; then
                suboptions="${suboptions} $1 $2"
                shift
            else
                suboptions="${suboptions} $1"
            fi
            shift
            ;;

        *)
            break
            ;;
     esac
done


if [ $# -lt ${minargs} ]; then
    echo "$0: too few arguments to subcommand \"${subcommand}\"" >& 2
    "${usage_func}" "usage: $0 " >& 2
    exit 3
fi
if [ $# -gt ${maxargs} ]; then
    echo "$0: too many arguments to subcommand \"${subcommand}\"" >& 2
    "${usage_func}" "usage: $0 " >& 2
    exit 3
fi


# read user configuration
if ! [ -r "${conf_file}" ]; then
    echo "$0: unable to read configuration file \"${conf_file}\"" >& 2
    exit 4
fi

. "${conf_file}"


case "${subcommand}" in
    initialize)
        if dmsetup ls 2> /dev/null | egrep "^${map_stem}	" > /dev/null; then
            echo "$0: snapshot origin device ${map_stem} already in use" >& 2
            exit 5
        fi

        if [ X"${dev_meta}" = X"" ] || [ X"${dev_meta}" = X"${dev_snapstore}" ]; then
            ddsnap ${subcommand} ${suboptions} "${dev_snapstore}" "${dev_origin}"
        else
            ddsnap ${subcommand} ${suboptions} "${dev_snapstore}" "${dev_origin}" "${dev_meta}"
        fi
        if [ $? -ne 0 ]; then
            echo "$0: mkddsnap failed to initialize the snapshot store" >& 2
            exit 5
        fi
        ;;

    create)
        originbase="`echo \"${dev_origin}\" | sed -e 's@^.*/@@'`"
        if ! egrep "${originbase}$" /proc/partitions > /dev/null 2>&1; then
            echo "$0: snapshot origin device ${dev_origin} not detected in /proc/partitions" >& 2
            exit 5
        fi
        originblocks="`egrep \" ${originbase}$\" /proc/partitions | awk '{ print $3 }'`"
        originsize="`expr 2 '*' \"${originblocks}\"`"

        if [ X"$1" = X"-1" ]; then
            if dmsetup ls 2> /dev/null | egrep "^${map_stem}	" > /dev/null; then
                echo "$0: snapshot origin device ${map_stem} already in use" >& 2
                exit 5
            fi
            echo 0 "${originsize}" ddsnap "${dev_snapstore}" "${dev_origin}" "${agent_sockpath}" "$1" |
                dmsetup create "${map_stem}"
            if [ $? -ne 0 ]; then
                echo "$0: dmsetup failed to create origin mapping" >& 2
                exit 5
            fi
        else
            if dmsetup ls 2> /dev/null | egrep "^${map_stem}$1	" > /dev/null; then
                echo "$0: snapshot device ${map_stem}$1 already in use" >& 2
                exit 5
            fi
            if ! ddsnap ${subcommand} ${suboptions} "${ddsnapd_sockpath}" "$1"; then
                echo "$0: ddsnap unable to create snapshot $1" >& 2
                exit 5
            fi
            echo 0 "${originsize}" ddsnap "${dev_snapstore}" "${dev_origin}" "${agent_sockpath}" "$1" |
                dmsetup create "${map_stem}$1"
            if [ $? -ne 0 ]; then
                echo "$0: dmsetup failed to create snapshot $1 mapping" >& 2
                exit 5
            fi
        fi
        ;;

    delete)
        if [ X"$1" = X"-1" ]; then
            dmsetup remove "${map_stem}"
        else
            dmsetup remove "${map_stem}$1"
            ddsnap ${subcommand} ${suboptions} "${ddsnapd_sockpath}" "$@"
        fi
        ;;

    list|priority|usecount|delta\ changelist|status)
        ddsnap ${subcommand} ${suboptions} "${ddsnapd_sockpath}" "$@"
        ;;

    delta\ create)
        ddsnap ${subcommand} ${suboptions} "$1" "$2" "$3" "$4"
        ;;

    delta\ apply)
        ddsnap ${subcommand} ${suboptions} "$1" "${map_path}/${map_stem}"
        ;;

    delta\ send)
        ddsnap ${subcommand} ${suboptions} "${ddsnapd_sockpath}" "$1" "$2" "${map_path}/${map_stem}" "$3" "$4"
        ;;

    delta\ listen)
        ddsnap ${subcommand} ${suboptions} -l "${ddsnap_delta_log}" -p "${ddsnap_delta_pid}" "${map_path}/${map_stem}" "$@"
        ;;

    agent)
        ddsnap ${subcommand} ${suboptions} -l "${ddsnap_agent_log}" -p "${ddsnap_agent_pid}" "${agent_sockpath}"
        ;;

    server)
        if [ X"${dev_meta}" = X"" ] || [ X"${dev_meta}" = X"${dev_snapstore}" ]; then
            ddsnap ${subcommand} ${suboptions} -l "${ddsnap_server_log}" -p "${ddsnap_server_pid}" "${dev_snapstore}" "${dev_origin}" "${agent_sockpath}" "${ddsnapd_sockpath}"
        else
            ddsnap ${subcommand} ${suboptions} -l "${ddsnap_server_log}" -p "${ddsnap_server_pid}" "${dev_snapstore}" "${dev_origin}" "${dev_meta}" "${agent_sockpath}" "${ddsnapd_sockpath}"
        fi
        ;;

    *)
        echo "$0: unhandled subcommand \"${subcommand}\"" >& 2
        exit 2
        ;;
esac

exit 0

