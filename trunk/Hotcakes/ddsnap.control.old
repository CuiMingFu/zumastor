#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <inttypes.h>
#include <netinet/in.h>
#include "ddsnap.h"
#include <time.h>
#include "../dm-ddsnap.h"
#include "trace.h"
#include "sock.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/un.h>

#define MAGIC_SIZE 8
#define CHANGELIST_MAGIC_ID "rln"
#define DELTA_MAGIC_ID "jc"

int eek() {
        error("%s (%i)", strerror(errno), errno);
        return 1;
}

int create_socket(char *sockname) {
	
	struct sockaddr_un addr = { .sun_family = AF_UNIX };
	int addr_len = sizeof(addr) - sizeof(addr.sun_path) + strlen(sockname);
	int sock;

	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		error("Can't get socket");
	strncpy(addr.sun_path, sockname, sizeof(addr.sun_path));
	if (sockname[0] == '@')
		addr.sun_path[0] = 0;

	if (connect(sock, (struct sockaddr *)&addr, addr_len) == -1)
		error("Can't connect to control socket");

        return sock;
}

int create_delta(char* changelistname, char* filename, char* dev1name, char* dev2name) {
	int changelist, snapdev2, check_chunk_num = 0, chunk_num = 0, deltafile = creat(filename, S_IRWXU);
    	char header[4], *chunkdata;
    	u64 chunkadd;
    	u32 chunk_size, chunk_size_bits;
	
	if (deltafile < 0) {
      		printf("delta file was not created properly.\n");
      		return 1;
    	}
 
	changelist = open(changelistname, O_RDONLY);
	snapdev2 = open(dev2name, O_RDONLY);

	if (changelist<0 || snapdev2<0) {
		printf("Either changelist or snapdev2 was not opened properly.\n");
		return 1;
	}

	/* Make sure it's a proper changelist */
	read(changelist,header,3);
	header[3] = 0;
	printf("header is %s\n", header);	
	if (strcmp(header,"rln") != 0) {
		printf("Not a changelist file.\n");
		return 1;
	}
         
	/* Variable set up */
	read(changelist, &check_chunk_num, sizeof(int));
	printf("chunk_num in changelist: %d\t", check_chunk_num);
	read(changelist, &chunk_size_bits, sizeof(u32));
	printf("chunksize bit: %u\t", chunk_size_bits);
	chunk_size = 1 << chunk_size_bits;
	printf("chunksize: %u\n", chunk_size);
	chunkdata = (char *)malloc (chunk_size);
	
	/* Header set-up */
	write(deltafile, &check_chunk_num, sizeof(int));
	write(deltafile, &chunk_size, sizeof(u32));
	write(deltafile, "jc", 2);
	
	/* Chunk address followed by CHUNK_SIZE bytes of chunk data */
	while (read(changelist, &chunkadd, sizeof(u64))>0) {
		chunk_num = chunk_num + 1;
		printf("current chunkadd: %Lu\n", chunkadd);
		chunkadd = chunkadd << chunk_size_bit;
		write(deltafile, &chunkadd, sizeof(u64));
		pread(snapdev2, chunkdata, chunk_size, chunkadd);
		write(deltafile, chunkdata, chunk_size);
	}

	/* Make sure everything in changelist was properly transmitted */
	if (chunk_num != check_chunk_num) {
		printf("Number of chunks don't match up.\n");
		return 1;
	}

	return 0;
}

int apply_delta (char* filename, char* devname) {
	int deltafile = open(filename, O_RDONLY), snapdev = open(devname, O_WRONLY);
	int check_chunk_num = 0, chunk_num = 0, chunk_size = 0;
	char header[3], *chunkdata;
	u64 chunkadd;

	if (deltafile<0 || snapdev<0) {
		printf("delta file or snapdev was not opened properly.\n");
		return 1;
	}
		
	read(deltafile, &check_chunk_num, sizeof(int));
	read(deltafile, &chunk_size, sizeof(int));
	read(deltafile, header, 2);
		
	/* Make sure it's a delta file */
	header[2] = 0;
	if (strcmp(header,"jc")!= 0) {
		printf("Not a delta file.\n");
		return 1;
	}
	chunkdata = (char *)malloc (chunk_size);
	while (read(deltafile, &chunkadd, sizeof(u64))>0) {
		printf("Updating chunkadd: %Lu\n", chunkadd);
		read(deltafile, chunkdata, chunk_size);
		pwrite(snapdev, chunkdata, chunk_size, chunkadd);
		chunk_num = chunk_num + 1;		
	}
			
	if (chunk_num != check_chunk_num) {
		printf("Number of chunks don't match up.\n");
		return 1;
	}
	       	
	return 0;
}

int list_snapshots(int sock){
	
	if (outbead(sock, LIST_SNAPSHOTS, struct create_snapshot, 0) < 0)
                return eek();
 	struct head head;
	unsigned maxbuf = 500;
	char buf[maxbuf];
        int err;
	if ((err = readpipe(sock, &head, sizeof(head))))
                return eek();
	
	struct snapinfo * buffer = (struct snapinfo *)malloc (head.length-sizeof(int));
        int i, count;
	
        readpipe(sock, &count, sizeof(int));
        readpipe(sock, buffer, head.length-sizeof(int));
	
        printf("Snapshot list: \n");
	
        for (i=0; i<count; i++) {
        	time_t snap_time = (time_t)(buffer[i]).ctime;
		
          	printf("Snapshot[%d]: \n", i);
	        printf("\tsnap.tag= %Lu \t", (buffer[i]).snap);
      		printf("snap.prio= %d \t", (buffer[i]).prio);
	        printf("snap.ctime= %s \n", ctime(&snap_time));
        }
	
        trace_on(printf("reply = %x\n", head.code);)
		err  = head.code != SNAPSHOT_LIST;
	
        if (head.code == REPLY_ERROR)
                error("%.*s", head.length - 4, buf + 4);
	
	return 0;
}


int generate_changelist(int sock, char* changelist_filename, int snap1, int snap2) {
	
	unsigned maxbuf = 500;
	char buf[maxbuf];
	
	int change_fd = open(changelist_filename, O_CREAT | O_TRUNC | O_WRONLY);

	if(change_fd < 0) 
		error("unable to open file: %s", changelist_filename);

	char magic[MAGIC_SIZE];

	bzero(magic, MAGIC_SIZE);
	strncpy(magic, CHANGELIST_MAGIC_ID, MAGIC_SIZE);
	if (write(change_fd, magic, MAGIC_SIZE) < 0)
		error("unable to write magic information to changelist file");
	fsync(change_fd);

	if (outbead(sock, GENERATE_CHANGE_LIST, struct generate_changelist, snap1, snap2) < 0)
		return eek();
	
	/* send fd to server */
	if( send_fd(sock, change_fd, "fark", 4) < 0)
		error("unable to send fd to server");
	
        struct head head;
	int err;
        if ((err = readpipe(sock, &head, sizeof(head))))
                return eek();
        assert(head.length < maxbuf); // !!! don't die
        if ((err = readpipe(sock, buf, head.length)))
                return eek();

        trace_on(printf("reply = %x\n", head.code);)
        err  = head.code != REPLY_GENERATE_CHANGE_LIST;

        if (head.code == REPLY_ERROR)
                error("%.*s", head.length - 4, buf + 4);

	close(change_fd);
        return 0;
}

int delete_snapshot(int sock, int snap) {

	if (outbead(sock, DELETE_SNAPSHOT, struct create_snapshot, snap) < 0)
                return eek();

	struct head head;
	unsigned maxbuf = 500;
	char buf[maxbuf];
	int err;

        if ((err = readpipe(sock, &head, sizeof(head))))
                return eek();
        assert(head.length < maxbuf); // !!! don't die
        if ((err = readpipe(sock, buf, head.length)))
                return eek();
        trace_on(printf("reply = %x\n", head.code);)
        err  = head.code != REPLY_DELETE_SNAPSHOT;

        if (head.code == REPLY_ERROR)
                error("%.*s", head.length - 4, buf + 4);

        return 0;
}

int create_snapshot(int sock, int snap) {
        if (outbead(sock, CREATE_SNAPSHOT, struct create_snapshot, snap) < 0)
                return eek();

        struct head head;
	unsigned maxbuf = 500;
	char buf[maxbuf];
	int err;
        if ((err = readpipe(sock, &head, sizeof(head))))
                return eek();
        assert(head.length < maxbuf); // !!! don't die
        if ((err = readpipe(sock, buf, head.length)))
                return eek();
        trace_on(printf("reply = %x\n", head.code);)
        err  = head.code != REPLY_CREATE_SNAPSHOT;

        if (head.code == REPLY_ERROR)
                error("%.*s", head.length - 4, buf + 4);

        return 0;
}

int set_priority(int sock, uint32_t tag_val, int8_t pri_val) {
        if (outbead(sock, SET_PRIORITY, struct create_snapshot, 0) < 0)
                return eek();

	struct snapinfo new_snap;
	new_snap.snap = tag_val;
	new_snap.prio = pri_val;
	writepipe(sock, &new_snap, sizeof(struct snapinfo));
	
	return 0;
}

int main(int argc, char *argv[]) {
	if (argc<2) {
		printf("Error!\n");
		exit(0);
	}
	char* command = argv[1];
	int sock;
	
	if (strcmp(command,"create-delta")==0) {
		if (argc!=6) {
			printf("Incorrect Format: ddsnap create-delta <changelist> <deltafile> <snapdev1> <snapdev2> \n");
			return 1;
		}
		return create_delta(argv[2],argv[3],argv[4],argv[5]);
	} else if (strcmp(command, "apply-delta")==0) {
		if (argc!=4) {
			printf("Incorrect Format: ddsnap apply-delta <deltafile> <dev> \n");
			return 1;
		}
		return apply_delta(argv[2],argv[3]);
	} else if (strcmp(command, "list") == 0 || strcmp(command, "list-snapshots") == 0) {
		if (argc < 3) {
			printf("Incorrect Format: ddsnap list-snapshots sockname\n");
			return 1;
		}
		sock = create_socket(argv[2]);
		return list_snapshots(sock);		
	} else if (strcmp(command, "delete-snapshot")==0) {
		if (argc < 4) {
			printf("Incorrect Format: ddsnap delete-snapshot sockname <snapshot>\n");
			return 1;
		}
		sock = create_socket(argv[2]);
		return delete_snapshot(sock,atoi(argv[3]));		
	} else if (strcmp(command, "create-snapshot")==0) {
		if (argc < 4) {
			printf("Incorrect Format: ddsnap create-snapshot sockname <snapshot>\n");
			return 1;
		} 
		sock = create_socket(argv[2]);
		return create_snapshot(sock,atoi(argv[3]));		
	} else if (strcmp(command, "generate-changelist")==0) {
		if (argc < 6) {
			printf("Incorrect Format: ddsnap generate-changelist sockname <changelist> <snapshot1> <snapshot2>\n");
			return 1;
		}
		sock = create_socket(argv[2]);
		return generate_changelist(sock, argv[3], atoi(argv[4]), atoi(argv[5]));		
	} else if (strcmp(command, "set-priority")==0) {
		if (argc < 5) {
			printf("Incorrect Format: ddsnap set-priority sockname <snap_tag> <new_priority_value>\n");
			return 1;
		}
		sock = create_socket(argv[2]);
		return set_priority(sock, atoi(argv[3]), atoi(argv[4]));		
	}

	/* Jump here for all unrecognized command */
	printf("Unrecognized command.\n");
	return 1;
	
}

