--- Linux/linux-2.6.21.1/kernel/fork.c	2007-04-27 14:49:26.000000000 -0700
+++ linux-2.6.21.1/kernel/fork.c	2007-08-22 16:08:17.000000000 -0700
@@ -875,6 +875,7 @@ static inline int copy_signal(unsigned l
 	sig->nvcsw = sig->nivcsw = sig->cnvcsw = sig->cnivcsw = 0;
 	sig->min_flt = sig->maj_flt = sig->cmin_flt = sig->cmaj_flt = 0;
 	sig->sched_time = 0;
+	sig->cmaxrss = 0;
 	INIT_LIST_HEAD(&sig->cpu_timers[0]);
 	INIT_LIST_HEAD(&sig->cpu_timers[1]);
 	INIT_LIST_HEAD(&sig->cpu_timers[2]);
--- Linux/linux-2.6.21.1/kernel/exit.c	2007-07-30 18:03:18.000000000 -0700
+++ linux-2.6.21.1/kernel/exit.c	2007-08-22 16:09:02.000000000 -0700
@@ -116,6 +116,11 @@ static void __exit_signal(struct task_st
 		sig->nvcsw += tsk->nvcsw;
 		sig->nivcsw += tsk->nivcsw;
 		sig->sched_time += tsk->sched_time;
+		if (tsk->mm != NULL) {
+			update_hiwater_rss(tsk->mm);
+			if (tsk->mm->hiwater_rss > sig->cmaxrss)
+				sig->cmaxrss = tsk->mm->hiwater_rss;
+		}
 		sig = NULL; /* Marker for below. */
 	}
 
@@ -904,6 +909,8 @@ fastcall NORET_TYPE void do_exit(long co
 	if (tsk->mm) {
 		update_hiwater_rss(tsk->mm);
 		update_hiwater_vm(tsk->mm);
+		if (tsk->mm->hiwater_rss > tsk->signal->cmaxrss)
+			tsk->signal->cmaxrss = tsk->mm->hiwater_rss;
 	}
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
 	if (group_dead) {
@@ -1194,6 +1201,8 @@ static int wait_task_zombie(struct task_
 			p->nvcsw + sig->nvcsw + sig->cnvcsw;
 		psig->cnivcsw +=
 			p->nivcsw + sig->nivcsw + sig->cnivcsw;
+		if (sig->cmaxrss > psig->cmaxrss)
+			psig->cmaxrss = sig->cmaxrss;
 		spin_unlock_irq(&p->parent->sighand->siglock);
 	}
 
--- Linux/linux-2.6.21.1/kernel/sys.c	2007-08-16 09:50:30.000000000 -0700
+++ linux-2.6.21.1/kernel/sys.c	2007-08-22 16:07:48.000000000 -0700
@@ -2002,6 +2002,7 @@ static void k_getrusage(struct task_stru
 	struct task_struct *t;
 	unsigned long flags;
 	cputime_t utime, stime;
+	unsigned long hiwater_rss;
 
 	memset((char *) r, 0, sizeof *r);
 	utime = stime = cputime_zero;
@@ -2021,9 +2022,12 @@ static void k_getrusage(struct task_stru
 			r->ru_nivcsw = p->signal->cnivcsw;
 			r->ru_minflt = p->signal->cmin_flt;
 			r->ru_majflt = p->signal->cmaj_flt;
+			r->ru_maxrss = p->signal->cmaxrss;
 
-			if (who == RUSAGE_CHILDREN)
+			if (who == RUSAGE_CHILDREN) {
+				r->ru_maxrss <<= PAGE_SHIFT - 10;
 				break;
+			}
 
 		case RUSAGE_SELF:
 			utime = cputime_add(utime, p->signal->utime);
@@ -2042,6 +2046,13 @@ static void k_getrusage(struct task_stru
 				r->ru_majflt += t->maj_flt;
 				t = next_thread(t);
 			} while (t != p);
+			update_hiwater_rss(p->mm);
+			hiwater_rss = p->mm->hiwater_rss;
+			if (hiwater_rss < p->signal->cmaxrss)
+				hiwater_rss = p->signal->cmaxrss;
+			if (r->ru_maxrss < hiwater_rss)
+				r->ru_maxrss = hiwater_rss;
+			r->ru_maxrss <<= PAGE_SHIFT - 10;
 			break;
 
 		default:
--- Linux/linux-2.6.21.1/include/linux/sched.h	2007-07-30 18:03:17.000000000 -0700
+++ linux-2.6.21.1/include/linux/sched.h	2007-08-22 16:08:07.000000000 -0700
@@ -457,6 +457,7 @@ struct signal_struct {
 	cputime_t utime, stime, cutime, cstime;
 	unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
 	unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
+	unsigned long cmaxrss;
 
 	/*
 	 * Cumulative ns of scheduled CPU time for dead threads in the
